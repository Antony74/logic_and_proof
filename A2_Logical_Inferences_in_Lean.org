#+Title: Logic and Proof
#+Author: [[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]], [[http://www.andrew.cmu.edu/user/rlewis1/][Robert Y. Lewis]],  [[http://www.contrib.andrew.cmu.edu/~fpv/][Floris van Doorn]]

* Logical Inferences in Lean

*** Implication

#+BEGIN_SRC lean
variables (A B : Prop)

example : A → B :=
assume H : A,
show B, from sorry

example : B := 
have H1 : A → B, from sorry,
have H2 : A, from sorry,
show B, from H1 H2
#+END_SRC

*** Conjunction

#+BEGIN_SRC lean
variables (A B : Prop)

example : A ∧ B :=
have H1 : A, from sorry,
have H2 : B, from sorry,
show A ∧ B, from and.intro H1 H2

example : A :=
have H : A ∧ B, from sorry,
show A, from and.left H

example : B :=
have H : A ∧ B, from sorry,
show B, from and.right H
#+END_SRC

*** Negation

#+BEGIN_SRC lean
variable A : Prop

example : ¬ A :=
assume H : A,
show false, from sorry

example : false :=
have H1 : ¬ A, from sorry,
have H2 : A, from sorry,
show false, from H1 H2
#+END_SRC

*** Disjunction

#+BEGIN_SRC lean
variables (A B C : Prop)

example : A ∨ B :=
have H : A, from sorry,
show A ∨ B, from or.inl H

example : A ∨ B :=
have H : B, from sorry,
show A ∨ B, from or.inr H

example : C :=
have H : A ∨ B, from sorry,
show C, from or.elim H
  (assume H1 : A,
    show C, from sorry)
  (assume H2 : B,
    show C, from sorry)
#+END_SRC

*** Truth and Falsity

#+BEGIN_SRC lean
variable A : Prop

example : A :=
have H : false, from sorry,
show A, from false.elim H

example : true :=
show true, by trivial
#+END_SRC

*** Bi-implication

#+BEGIN_SRC lean
variables (A B : Prop)

example : A ↔ B :=
iff.intro
  (assume H : A,
    show B, from sorry)
  (assume H : B,
    show A, from sorry)

example : B :=
have H1 : A ↔ B, from sorry,
have H2 : A, from sorry,
show B, from iff.mp H1 H2

example : A :=
have H1 : A ↔ B, from sorry,
have H2 : B, from sorry,
show A, from iff.mpr H1 H2
#+END_SRC

*** Reductio ad absurdum (proof by contradiction)

#+BEGIN_SRC lean
open classical

variable (A : Prop)

example : A :=
by_contradiction
  (assume H : ¬ A,
    show false, from sorry)
#+END_SRC

*** Universal quantifier

#+BEGIN_SRC lean
variable U : Type
variable P : U → Prop
variable a : U

example : ∀ x, P x :=
take x,
show P x, from sorry

example : P a :=
have H : ∀ x, P x, from sorry,
show P a, from H a
#+END_SRC

*** Existential quantifier

#+BEGIN_SRC lean
variable U : Type
variable P : U → Prop
variable Q : Prop
variable y : U

example : ∃ x, P x :=
have H : P y, from sorry,
exists.intro y H

example : Q :=
have H1 : ∃ x, P x, from sorry,
obtain (y : U) (H2 : P y), from H1,
show Q, from sorry
#+END_SRC

*** Equality

#+BEGIN_SRC lean
variable A : Type

variables x y z : A
variable P : A → Prop

example : x = x :=
show x = x, from eq.refl x

example : y = x :=
have H : x = y, from sorry,
show y = x, from eq.symm H

example : x = z :=
have H1 : x = y, from sorry,
have H2 : y = z, from sorry,
show x = z, from eq.trans H1 H2

example : P y :=
have H1 : x = y, from sorry,
have H2 : P x, from sorry,
show P y, from eq.subst H1 H2
#+END_SRC 

Using the =eq.ops= notation:

#+BEGIN_SRC lean
variable A : Type

variables x y z : A
variable P : A → Prop

-- BEGIN
open eq.ops

example : x = x :=
show x = x, from rfl

example : y = x :=
have H : x = y, from sorry,
show y = x, from H⁻¹

example : x = z :=
have H1 : x = y, from sorry,
have H2 : y = z, from sorry,
show x = z, from H1 ⬝ H2

example : P y :=
have H1 : x = y, from sorry,
have H2 : P x, from sorry,
show P y, from H1 ▸ H2
-- END
#+END_SRC

You can also write proofs using =calc=, as described in the text.

*** Using =have= and =show=

Lean proofs often have the following form:
#+BEGIN_SRC text
example : B :=
have H1 : A1, from P1,
have H2 : A2, from P2,
...
have Hn : An, from Pn,
show B, from Q
#+END_SRC
Notes:
- A =have= is never strictly necessary, since you can instead insert
  the proof =Pi= wherever the label =Hi= was used. The =have= command
  supports working forwards in incremental steps, and makes proofs
  more readable.
- A =show= is usually not necessary either. At any point in a Lean
  proof there is a current goal, and Lean can generally infer the goal
  from the surrounding context. The =show= command makes the goal
  explicit, and makes the proof more readable.
- A justification =Pi= may be a simple expression like =and.intro H1
  H2=. But it can be a longer proof, possibly involving =have= and
  =show=. For example, you can prove =A ∧ B= with the expression
  =and.intro P1 P2=, where =P1= is any proof of =A=, and =P2= is any
  proof of =B=, no matter how long. In general, you will need to put
  =P1= and =P2= in parentheses, and you should indent the subproofs to
  make the structure clear.
- The standard way to prove an implication =A → B= is to assume =A=
  and prove =B=. In other words, if the goal is to prove =A → B=,
  after the line =assume H : A=, the goal is to prove =B=, where now
  the extra hypothesis =H= has been added to the context. Similarly,
  the standard way to prove =¬ A= and prove false.
- The =or.elim= rule takes three arguments to prove a statement =C=: a
  proof =P1= of a disjunction =A ∨ B=, a proof =P2= of =A → C=, and a
  proof =P3= of =B → C=. You can give the proofs =P2= and =P3= before
  the =or.elim= using =have=, but it is usually more natural to write
  it as a case split, as above. Similar considerations hold for
  =iff.elim=.

*** Unicode symbols

| Unicode | Ascii    | Editor                  |
|---------+----------+-------------------------|
| ¬       | not      | =\not=, =\neg=          |
| ∧       | /\       | =\and=                  |
| ‌∨       | \/       | =\or=                   |
| →       | ->       | =\to=, =\r=, =\implies= |
| ↔       | <->      | =\iff=, =\lr=           |
| ∀       | forall   | =\all=                  |
| ∃       | exists   | =\ex=                   |
| λ       | fun      | =\lam=, =\fun=          |
| ≠       | ~=       | =\ne=                   |
| ×       | prod     | =\times=                |
| ℕ       | nat      | =\nat=                  |
| ℤ       | int      | =\int=                  |
| ℚ       | rat      | =\rat=                  |
| ℝ       | real     | =\real=                 |
| α       |          | =\alpha=                |
| β       |          | =\beta=                 |
| γ       |          | =\gamma=                |
| ⁻¹      | eq.symm  | =\sy=, =\inv=, =\-1=    |
| ⬝       | eq.trans | =\tr=                   |
| ▸       | eq.subst | =\t=                    |
| ∈       | mem      | =\in=                   |
| ∉       |          | =\nin=                  |
| ∩       | inter    | =\i=                    |
| ∪       | union    | =\un=                   |
| ⊆       | subseteq | =\subeq=                |
| ≤       | <=       | =\le=                   |
| ≥       | >=       | =\ge=                   |
| ∣       | dvd      | =\∣=                    |
| ≡       |          | =\equiv=                |
| ≈       |          | =\eq=                   |
| ∘       | comp     | =\comp=                 |

